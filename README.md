# FieldTools
{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import sys\n",
    "import os\n",
    "import subprocess\n",
    "import numpy as np  \n",
    "import pytraj as pt\n",
    "import pickle\n",
    "import datetime\n",
    "\n",
    "def fkt_project_fields(Field_Vectors,FIELDS,Field,VEC):\n",
    "    \n",
    "    for Field_Component in Field_Vectors: \n",
    "        \n",
    "        if len(Field.split(\"_\")) == 1:   #POINT CALCULATION\n",
    "            x = Field_Vectors[Field_Component]\n",
    "            Field_Vectors[Field_Component]=sum(x*x)**0.5\n",
    "            \n",
    "        if len(Field.split(\"_\")) == 2:   #VECTOR CALCULATION\n",
    "            Field_Vectors[Field_Component]=np.dot(Field_Vectors[Field_Component],VEC)\n",
    "        ### 1 a.u. = 5.14x10^9 V/cm\n",
    "        ### 1 a.u. = 5.14x10^3 MV/cm\n",
    "        FIELDS[Field][Field_Component]+=[Field_Vectors[Field_Component]*5.14*1000]\n",
    "    return FIELDS\n",
    "\n",
    "def fkt_Update_Charges(QM_Charges,QM_Dict,Frame_i,Names,Charges):\n",
    "    stop=\"X\"\n",
    "    for QM_Charge_i in range(0,len(QM_Charges),1):\n",
    "        if len(QM_Charges[QM_Charge_i])<>1: continue\n",
    "        if QM_Charges[QM_Charge_i][0]==str(Frame_i+1):\n",
    "            start = QM_Charge_i+1\n",
    "        if QM_Charges[QM_Charge_i][0]==str(Frame_i+2):\n",
    "            stop = QM_Charge_i\n",
    "            QM_Charges = QM_Charges[start:stop]\n",
    "            break\n",
    "    if stop == \"X\":\n",
    "        QM_Charges = QM_Charges[start:]       \n",
    "    #print QM_Charges\n",
    "            \n",
    "    for QM_Atom_i in range(0,len(QM_Dict),1):\n",
    "        for Atom_i in range(0,len(Names),1):\n",
    "            if Names[Atom_i][2] == QM_Dict[QM_Atom_i][2]:      #QM_Atom_i index in QM_Charges to be changed from   \n",
    "                if Names[Atom_i][0] == QM_Dict[QM_Atom_i][0]:  #Atom_i index in Charges to be changed \n",
    "                    #print QM_Atom_i\n",
    "                    #print Names[Atom_i],QM_Dict[QM_Atom_i]\n",
    "                    #print Charges[Atom_i],QM_Charges[QM_Atom_i]\n",
    "                    Charges[Atom_i]=QM_Charges[QM_Atom_i][2]\n",
    "                    break\n",
    "    return Charges\n",
    "\n",
    "def fkt_Load_QM_Charges(arg_qm_charges,arg_qm_dict):\n",
    "    with open(arg_qm_charges) as f:\n",
    "        QM_Charges = [i.split() for i in f.readlines()]\n",
    "    with open(arg_qm_dict) as f:\n",
    "        QM_Dict = [i.split() for i in f.readlines()]\n",
    "    return QM_Charges,QM_Dict\n",
    "\n",
    "def Field_of_ABC_at_XYZ(_ABC,_XYZ,_Charge):\n",
    "    \n",
    "    # Field at _xyz from Atom _abc with _Charge \n",
    "    _Couloumb_Const = 1.00 #(A.U.)\n",
    "    _Vector = _ABC-_XYZ        \n",
    "    _Length = np.linalg.norm(_Vector)\n",
    "    _Normalized_Vector = (-1.0)*_Vector/_Length\n",
    "    _Length_Bohr = _Length/0.529177249           # Bohr\n",
    "    _Field = (_Couloumb_Const*_Charge/(_Length_Bohr**2))*_Normalized_Vector\n",
    "    return _Field\n",
    "\n",
    "def fkt_calc_field_vectors_at_XYZ(XYZ,Frame,Charges,Names,Field_Components,arg_solvent,Self_i,Field):\n",
    "      \n",
    "#### VARIABLES STRUCTURE\n",
    "    Field_Vectors = {}\n",
    "    for Field_Component in Field_Components:\n",
    "        Field_Vectors[Field_Component] = np.array([0.0,0.0,0.0])\n",
    "        \n",
    "    for Atom_Index in range(0,len(Frame),1):   \n",
    "\n",
    "#### Exclude Self-residue!!! \n",
    "        if Names[Atom_Index][2] == Self_i: continue\n",
    "#### CALCULATE Vector Bond-Center to      Atom              , Ligand , Charge\n",
    "        Field_Vector = Field_of_ABC_at_XYZ(Frame[Atom_Index], XYZ    , Charges[Atom_Index], Field)\n",
    "            \n",
    "        #### Total Field\n",
    "        Field_Vectors[\"Total\"]+=Field_Vector\n",
    "        #### Solvent Field\n",
    "        if Names[Atom_Index][1] in arg_solvent:\n",
    "            Field_Vectors[\"Solvent\"]+=Field_Vector\n",
    "            Field_Vectors[Names[Atom_Index][1]]+=Field_Vector\n",
    "        else:\n",
    "            Field_Vectors[\"Protein\"]+=Field_Vector\n",
    "            Field_Vectors[Names[Atom_Index][2]]+=Field_Vector\n",
    "            \n",
    "    return Field_Vectors\n",
    "\n",
    "def fkt_Field_Components(FIELDS,Names,arg_solvent):\n",
    "    \n",
    "    Field_Components = [\"Total\",\"Protein\",\"Solvent\"]+arg_solvent\n",
    "    \n",
    "    for Name in Names:\n",
    "        if Name[1] not in arg_solvent:\n",
    "            if Name[2] not in Field_Components: Field_Components += [Name[2]] \n",
    "\n",
    "    for Field in FIELDS:\n",
    "        for Field_Component in Field_Components:\n",
    "            FIELDS[Field][Field_Component]=[]\n",
    "    \n",
    "    return FIELDS,Field_Components\n",
    "\n",
    "def fkt_get_Target_VEC(Target_XYZ):\n",
    "    \n",
    "    Target_VEC = {}\n",
    "\n",
    "    for Target in Target_XYZ:\n",
    "        if len(Target_XYZ[Target])==2:\n",
    "            Target_VEC[Target]={}\n",
    "            XYZ_START = Target_XYZ[Target][0]\n",
    "            XYZ_STOP  = Target_XYZ[Target][1]\n",
    "            Target_VEC[Target][\"Center\"] = (XYZ_START+XYZ_STOP)/2 \n",
    "            Target_VEC[Target][\"Vector\"] = (XYZ_STOP-XYZ_START)/np.linalg.norm(XYZ_STOP-XYZ_START)\n",
    "            \n",
    "    return Target_VEC\n",
    "\n",
    "def fkt_Target_Index(Names,arg_target,FIELDS):\n",
    "    \n",
    "    Target_Index={}\n",
    "    \n",
    "    with open(arg_target) as f:\n",
    "        Targets = [i.split() for i in f.readlines()]\n",
    "        \n",
    "    for Target_i in range(0,len(Targets),1):\n",
    "        Target_Name = \"_\".join(Targets[Target_i])\n",
    "        FIELDS[Target_Name]={}\n",
    "        for Atom_i in range(0,len(Targets[Target_i]),1): #If this is a vector, it contains two Atoms!\n",
    "            Atom_ResidueNr = Targets[Target_i][Atom_i].split(\"@\")[0][1:]\n",
    "            Atom_Name      = Targets[Target_i][Atom_i].split(\"@\")[1]\n",
    "            for PDB_i in range(0,len(Names),1):\n",
    "                if Atom_ResidueNr == Names[PDB_i][2]:      #Check if Residue Number matches\n",
    "                    if Atom_Name == Names[PDB_i][0]:       #Check if Atom Name matches\n",
    "                        Targets[Target_i][Atom_i] = PDB_i  #Update Number in Target\n",
    "                        break\n",
    "        Target_Index[Target_Name] = Targets[Target_i]\n",
    "    return Target_Index,FIELDS #Passed to Target_Index in main!\n",
    "\n",
    "def fkt_get_Target_XYZ(Frame,Target_Index):\n",
    "\n",
    "#Make empty library\n",
    "    Target_XYZ = {}\n",
    "\n",
    "    for Target in Target_Index:\n",
    "        Target_XYZ[Target]=[]\n",
    "        for Atom_i in range(0,len(Target_Index[Target]),1): #If this is a vector, it contains two Atoms!\n",
    "            Target_XYZ[Target]=Target_XYZ[Target]+[Frame[Target_Index[Target][Atom_i]]]\n",
    "                \n",
    "    return Target_XYZ #Passed to Target_Index in main!\n",
    "\n",
    "def fkt_Load_Trajectory(arg_nc,arg_param,arg_pdb):\n",
    "\n",
    "    traj = pt.load(arg_nc, arg_param) \n",
    "    Trajectory = traj.xyz\n",
    "    Charges = traj.topology.charge\n",
    "\n",
    "    with open(arg_pdb) as f:\n",
    "        Names = [i for i in f.readlines() if len(i)==81] # PDB lines of Atoms and their xyz coords have 81 characters\n",
    "    for i in range(0,len(Names),1):\n",
    "        temp = Names[i].split()\n",
    "####################AtmName , ResName , ResiNR\n",
    "####################0       , 1       , 2        \n",
    "        Names[i] = [temp[2], temp[3], temp[4]]   \n",
    "    return (Trajectory, Charges, np.array(Names))\n",
    " \n",
    "def make_pdb(arg_tmp_dir,arg_nc,arg_param,arg_pdb):\n",
    "    cpptraj = \"\"\"parm \"\"\"+arg_param+\"\"\"\n",
    "trajin \"\"\"+arg_nc+\"\"\"\n",
    "autoimage    \n",
    "outtraj \"\"\"+arg_pdb+\"\"\" onlyframes -1\n",
    "strip !(\"\"\"+arg_qm_mask+\"\"\")\n",
    "outtraj \"\"\"+\".\".join(arg_out.split(\".\")[:-1])+\"\"\".pdb onlyframes -1\n",
    "\"\"\"\n",
    "    with open(arg_tmp_dir+\"cpptraj.in\", \"w\") as f:\n",
    "        f.write(cpptraj)  \n",
    "    with open(arg_tmp_dir+\"/cppraj.out\", 'w') as f:\n",
    "        process = subprocess.call(['cpptraj', '-i', arg_tmp_dir+'cpptraj.in'], stdout=f)\n",
    "    \n",
    "def make_tmpdir(arg_tmp_dir):\n",
    "    if os.path.isdir(arg_tmp_dir):\n",
    "        for f in os.listdir(arg_tmp_dir):\n",
    "            os.remove(os.path.join(arg_tmp_dir, f))\n",
    "    else:\n",
    "        os.mkdir(arg_tmp_dir)\n",
    "        \n",
    "def load_qm_mask(arg_qm_mask):\n",
    "    with open(arg_qm_mask) as f:\n",
    "        arg_qm_mask = f.read()[:-1]\n",
    "    return arg_qm_mask\n",
    "\n",
    "def usage():\n",
    "    print \"                                                                                                               \"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-------------                                 FieldTools Usage:                                 -------------|\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-nc             : Specify trajectory file                                                                    |\"\n",
    "    print \"|-parm           : Specify parameter file                                                                     |\"\n",
    "    print \"|-out            : Specify output file                                                                        |\"\n",
    "    print \"|-tmp_dir        : Optional: Specify temporary directory                                [default ./tmp_field/]|\"\n",
    "    print \"|-target         : Specify target file                                                                        |\"\n",
    "    print \"|-solvent        : Optional: Comma seperated list of non-protein residues               [default WAT,Na+,Cl- ]|\"\n",
    "    print \"|-use_qm_charges : Optional: Specify if qmcharges should be read                        [default false       ]|\"\n",
    "    print \"|-exclude_atoms  : Optional: Specify what atoms will be excluded from Field calculation                       |\"\n",
    "    print \"|                : If not set, Field calculation will exclude the full residue of the first atom defined      |\"\n",
    "    print \"|                : for each target.                                                                           |\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-------------         If -use_qm_charges = true, the following options have to be set:          -------------|\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-qm_mask        : Specify qm region (amber selection mask)                                                   |\"\n",
    "    print \"|-qm_charges     : Specify qmcharges file (qm partial charges of each frame, made with QMChargesTools)        |\"\n",
    "    print \"|-qm_dict        : Specify qmdict file (containing qmatom names in .pdb and gaussian)                         |\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-------------                               How to define -target:                              -------------|\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-target should point to a file, each line in that file defines target to calculate the Field                 |\"\n",
    "    print \"|Targets are selected using the amber selection syntax                                                        |\"\n",
    "    print \"|To calculate the magnitude of the field at a specific atom:     :47@OG                                       |\"\n",
    "    print \"|To calculate the magnitude of the field projected along a bond: :47@OG :47@OH                                |\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|-------------                                       INFO                                        -------------|\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\"\n",
    "    print \"|Script recognizes if total field at one point or projection onto a bond is to be calculated                  |\"\n",
    "    print \"|based on the input in -target                                                                                |\"\n",
    "    print \"|-------------                                                                                                |\"\n",
    "    print \"|Script excludes all Field contributions of the Residue at which the field is calculated.                     |\"\n",
    "    print \"|For Vector Projections, this is only the first residue number!                                               |\"\n",
    "    print \"|-------------                                                                                                |\"\n",
    "    print \"|Solvent = All atoms as defined in -solvent,                                                                  |\"\n",
    "    print \"|          for these residues contributions will also be grouped based on the residue name                    |\"\n",
    "    print \"|Protein = All atoms that are not part of -solvent,                                                           |\"\n",
    "    print \"|          for the protein, per-reside fields will be calculated                                              |\"\n",
    "    print \"|-------------                                                                                                |\"\n",
    "    print \"|Linker Atom charge is ignored!                                                                               |\"\n",
    "    print \"|-------------------------------------------------------------------------------------------------------------|\" \n",
    "    \n",
    "def inputParser(arg):\n",
    "    \n",
    "    arg_nc            = False                                                                         ### Add new flag here\n",
    "    arg_param         = False\n",
    "    arg_out           = False\n",
    "    arg_tmp_dir       =\"tmp_field/\"   \n",
    "    arg_target        = False\n",
    "    arg_solvent       = \"WAT,Na+,Cl-\"\n",
    "    arg_exclude_atoms = \"All atoms of the residue defined in the first Atom for each Target.\"\n",
    "    arg_use_qmcharges = False\n",
    "    arg_qm_mask       = False\n",
    "    arg_qm_charges    = False\n",
    "    arg_qm_dict       = False\n",
    "    \n",
    "    if(len(arg) == 1) or arg[1] in [\"-help\",\"--help\",\"-h\"]:\n",
    "        usage()\n",
    "        quit()\n",
    "    \n",
    "    for index in range(1,len(arg)-1,2):\n",
    "        param = arg[index]\n",
    "        if param==\"-nc\"             : arg_nc            = os.getcwd()+\"/\"+str(arg[index+1])           ### Add new flag here\n",
    "        if param==\"-parm\"           : arg_param         = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "        if param==\"-out\"            : arg_out           = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "        if param==\"-tmp_dir\"        : arg_tmp_dir       = os.getcwd()+\"/\"+str(arg[index+1])+\"/\"\n",
    "        if param==\"-target\"         : arg_target        = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "        if param==\"-solvent\"        : arg_solvent       = str(arg[index+1])\n",
    "        if param==\"-exclude_atoms\"  : arg_exclude_atoms = str(arg[index+1])\n",
    "        if param==\"-use_qm_charges\" : arg_use_qmcharges = str(arg[index+1])\n",
    "        if param==\"-qm_mask\"        : arg_qm_mask       = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "        if param==\"-qm_charges\"     : arg_qm_charges    = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "        if param==\"-qm_dict\"        : arg_qm_dict       = os.getcwd()+\"/\"+str(arg[index+1])\n",
    "\n",
    "                                                                                                      ### Add new flag here\n",
    "    if arg_nc        == False: print \"ERROR. Please specify the name of the trajectory file with -nc\"  \n",
    "    if arg_param     == False: print \"ERROR. Please specify the name of the parameter file with -parm\"\n",
    "    if arg_out       == False: print \"ERROR. Please specify the name of the output file with -out\"\n",
    "    if arg_target    == False: print \"ERROR. Please specify the name of the target file with -target. \\\n",
    "                                      \\n -> See examples with --help\"\n",
    "    if arg_use_qmcharges == \"True\":\n",
    "        if arg_qm_mask    == False: print \"ERROR. Please specify qm mask with -qm_mask\"\n",
    "        if arg_qm_charges == False: print \"ERROR. Please specify charge of the qm region with -qm_charge\"\n",
    "        if arg_qm_dict    == False: print \"ERROR. Please specify qm_dict with -qm_dict\"\n",
    "        \n",
    "    if False in [arg_nc,arg_param,arg_out,arg_tmp_dir,arg_target]:                                   ### Add new flag here\n",
    "        usage()\n",
    "        quit()\n",
    "    if arg_use_qmcharges == \"True\":\n",
    "        if False in [arg_qm_mask,arg_qm_charges,arg_qm_dict]:                                        ### Add new flag here\n",
    "            usage()\n",
    "            quit()\n",
    "    \n",
    "    print \"-nc              Trajectory file      : \",arg_nc                                          ### Add new flag here\n",
    "    print \"-parm            Parameter file       : \",arg_param\n",
    "    print \"-out             Output file          : \",arg_out\n",
    "    print \"-tmp_dir         Temporary dir        : \",arg_tmp_dir\n",
    "    print \"-target          Field target         : \",arg_target\n",
    "    print \"-arg_solvent     Non-protein residues : \",arg_solvent\n",
    "    print \"-exclude_atoms   Atoms excluded       : \",arg_exclude_atoms\n",
    "    if arg_use_qmcharges == \"True\":\n",
    "        print \"-use_qm_charges  QM_theory            :  True\"\n",
    "        print \"-qm_mask         QM region            : \",arg_qm_mask\n",
    "        print \"-qm_charges      QM charges           : \",arg_qm_charges\n",
    "        print \"-qm_dict         QM dict              : \",arg_qm_dict \n",
    "    \n",
    "    return arg_nc,arg_param,arg_out,arg_tmp_dir,arg_target,arg_solvent,arg_exclude_atoms,\\\n",
    "           arg_use_qmcharges,arg_qm_mask,arg_qm_charges,arg_qm_dict                                  ### Add new flag here\n",
    "    \n",
    "########################\n",
    "### THE FINAL SCRIPT ###\n",
    "########################\n",
    "### Read in arguments                                                                             \n",
    "arg_nc,arg_param,arg_out,arg_tmp_dir,arg_target,arg_solvent,arg_exclude_atoms,\\\n",
    "           arg_use_qmcharges,arg_qm_mask,arg_qm_charges,arg_qm_dict=inputParser(sys.argv)            ### Add new flag here\n",
    "arg_solvent = arg_solvent.split(\",\")\n",
    "\n",
    "#Load qm_mask.in\n",
    "arg_qm_mask = load_qm_mask(arg_qm_mask)\n",
    "\n",
    "print \"\\nField calculation RUNNING : \",datetime.datetime.now() \n",
    "\n",
    "### Empty dictionary storing all Fields\n",
    "FIELDS = {}\n",
    "\n",
    "### Make tmpdir\n",
    "make_tmpdir(arg_tmp_dir)\n",
    "\n",
    "### Make pdb of system and qm_mm region\n",
    "arg_pdb = \".\".join(arg_out.split(\".\")[:-1])+\"_full.pdb\"\n",
    "make_pdb(arg_tmp_dir,arg_nc,arg_param,arg_pdb)\n",
    "\n",
    "### Load QM charges\n",
    "if arg_use_qmcharges == \"True\":\n",
    "    QM_Charges,QM_Dict = fkt_Load_QM_Charges(arg_qm_charges,arg_qm_dict) \n",
    "    #print \"QM_Dict :\", QM_Dict,\"\\n\"      \n",
    "    #print \"QM_Charges :\", QM_Charges[:50],\"\\n\"\n",
    "     \n",
    "### Load Trajectory\n",
    "Trajectory, Charges, Names = fkt_Load_Trajectory(arg_nc,arg_param,arg_pdb)\n",
    "#print \"Trajectory :\", Trajectory,\"\\n\"\n",
    "#print \"Charges :\", Charges,\"\\n\"\n",
    "#print \"Names :\", Names,\"\\n\"\n",
    " \n",
    "### Load Index of Target Atoms for Field calculation\n",
    "Target_Index,FIELDS = fkt_Target_Index(Names,arg_target,FIELDS)\n",
    "#print \"Target_Index:\", Target_Index,\"\\n\"\n",
    "#print \"Field_Dict:\", FIELDS,\"\\n\"\n",
    "\n",
    "### Define Field Components (Total,Protein,Solvent,Each residue,Each solvent type) to calculate\n",
    "FIELDS,Field_Components = fkt_Field_Components(FIELDS,Names,arg_solvent)\n",
    "#print \"Field_Dict:\", FIELDS,\"\\n\"\n",
    "\n",
    "### Loop through Trajectory to calculate Fields\n",
    "for Frame_i in range(0,len(Trajectory),1):\n",
    "\n",
    "### Get XYZ coordinates of the Target Atoms\n",
    "    Target_XYZ=fkt_get_Target_XYZ(Trajectory[Frame_i],Target_Index)\n",
    "    #print \"Target_XYZ:\",Target_XYZ,\"\\n\"\n",
    "    Target_VEC=fkt_get_Target_VEC(Target_XYZ)\n",
    "    #print \"Target_VEC:\",Target_VEC,\"\\n\"    \n",
    "### Update QM_Charges\n",
    "    if arg_use_qmcharges == \"True\":\n",
    "        Charges = fkt_Update_Charges(QM_Charges,QM_Dict,Frame_i,Names,Charges)  \n",
    "        #print \"Charges :\", Charges,\"\\n\"    \n",
    "        \n",
    "### Loop through FIELDS to calculate each Target\n",
    "    for Field in FIELDS:\n",
    "        if len(Field.split(\"_\")) == 1:   #POINT CALCULATION\n",
    "            XYZ = Target_XYZ[Field][0]\n",
    "            VEC = \"\"\n",
    "        if len(Field.split(\"_\")) == 2:   #VECTOR CALCULATION\n",
    "            XYZ = Target_VEC[Field]['Center']\n",
    "            VEC = Target_VEC[Field]['Vector']\n",
    "        Self_i = Field.split(\"@\")[0][1:]\n",
    "        \n",
    "### Calculate Field Vectors at position XZY        \n",
    "        Field_Vectors = fkt_calc_field_vectors_at_XYZ(XYZ,Trajectory[Frame_i],Charges,Names,\\\n",
    "                                                      Field_Components,arg_solvent,Self_i,Field)\n",
    "        #for Field_Component in Field_Vectors:\n",
    "        #    print Field_Component,Field_Vectors[Field_Component]\n",
    "\n",
    "### Calculate Field Magnitude either at specific point or projected onto Bond            \n",
    "        FIELDS = fkt_project_fields(Field_Vectors,FIELDS,Field,VEC)\n",
    "        #for Field_Component in FIELDS[Field]:\n",
    "        #    print Field,Field_Component,FIELDS[Field][Field_Component]    \n",
    "        \n",
    "print \"\\nField calculation DONE : \",datetime.datetime.now()         \n",
    "pickle.dump(FIELDS,open(arg_out,\"wb\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 2",
   "language": "python",
   "name": "python2"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 2
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython2",
   "version": "2.7.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
